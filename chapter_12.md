# Основные типы данных

## Числа

### Общие принципы

- Используйте в чистом видео только числа `0` и `1`, а любые другие числа храните как переменные с понятными именами или как именованные константы
- Если в программе есть возможность деления на ноль, добавьте проверку, чтобы предупредить такую ошибку
- Не сравнивайте данные разных типов — выполните преобразование типов вручную перед сравнением
- Обратите внимание на предупреждения компилятора и исправьте связанные с ними проблемы

### Целые числа

Основная проблема, связанная с использованием целых чисел, — [проблема переполнения](https://en.wikipedia.org/wiki/Integer_overflow) — возникает, когда число, которое нужно сохранить, превышает возможности выбранного типа. Например, если попытаться сохранить `1 000 000 000 000` в переменную типа `int`. Поэтому, при выполнении арифметических операций, нужно принимать во внимание наибольшие возможные значения целых чисел — как для конечного результата вычисления, так и для промежуточных этапов. И, исходя из этого, выбирать подходящий тип числа.

_Интервалы значений некоторых целых типов_

| Число     | Без знака                              | Со знаком                                                      |
| --------- | -------------------------------------- | -------------------------------------------------------------- |
| 8-битное  | от `0` до `255`                        | от `-128` до `127`                                             |
| 16-битное | от `0` до `65 535`                     | от `-32 768` до `32 767`                                       |
| 32-битное | от `0` до `4 294 967 295`              | от `-2 147 483 648` до `2 147 484 647`                         |
| 64-битное | от `0` до `18 446 744 073 709 551 615` | от `-9 223 372 036 854 775 808` до `9 223 372 036 854 775 807` |

Предположим, что нам нужно выполнить такое вычисление на Java.

```java
class Main {
  public static void main(String[] args) {
    int product = (1000000 * 1000000) / 1000000
    System.out.println(product); // Ожидаем 1000000, а получим -727
  }
}
```

Несмотря на то, что в результате деления мы ожидаем получить `1 000 000`, который может быть представлен как 32-битное число, промежуточная операция умножения вернёт `1 000 000 000 000`, который программа не сможет корректно запомнить и вместо этого запомнит `-727 379 968` (это значение можно рассчитать [по формуле](https://stackoverflow.com/a/23481542)). Именно поэтому после деления мы получим `-727`, а вовсе не `1 000 000`.

Чтобы решить проблему переполнения, мы можем использовать тип `long` или класс `BigInteger`, который реализует числа произвольной длины ([arbitary-precision integers](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic)), то есть такие числа, в которых количество цифр и количество знаков после запятой ограничено только доступной памятью.

```java
import java.math.*;

class Main {
  public static void main(String[] args) {
    BigInteger a = BigInteger.valueOf(1000000);
    BigInteger b = BigInteger.valueOf(1000000);
    BigInteger product = a.multiply(b).divide(BigInteger.valueOf(1000000));
    System.out.println(product); // 1000000
  }
}
```

В некоторых языках, например, в Python по умолчанию используются числа произвольной длины.

### Числа с плавающей точкой

> Главная особенность применения чисел с плавающей запятой в том, что многие дробные десятичные числа не могут быть точно представлены с помощью нулей и единиц, используемых в цифровом компьютере. В бесконечных десятичных дробях, таких как 1/3 или 1/7, обычно сохраняются только 7 или 15 цифр после запятой (с. 286).

- Избегайте сложения и вычитания слишком разных по размеру чисел (например, 32-битного числа недостаточно, чтобы сохранить разницу между `1 000 000` и `0.1`, из-за чего возникнет ошибка)
- Избегайте сравнения чисел с плавающей точкой на равенство, потому что их действительное значение может отклоняться от ожидаемого через несколько знаков после запятой (например, ожидаем `1.0`, а имеем `1.000000000001`)
- Предупреждайте ошибки округления
  - Используйте большую точность, чем это необходимо
  - Используйте binary-coded decimal (BCD)
  - Используйте целые числа, например, учитывайте деньги в центах вместо долларов

## Символы и строки

- Используйте для хранения строк переменные с понятным именем
  - Если эта строка встречается чаще одного раза
  - Если по тексту строки непонятно, что она означает (например, `0x1B`)
- Используйте для хранения строк внешние файлы
  - Если планируется перевод строк на несколько языков (можно использовать `po` и `mo` файлы в рамках системы интернационализации `gettext`)
  - Если строк очень много и есть риск, что возникнет проблема с их хранением из-за недостатка памяти (оптимизировать хранение отдельных файлов легче, чем оптимизировать всё приложение)
- Используйте `Unicode`, если планируете интернационализацию приложение. Если нет, можно рассмотреть другие кодировки, например, `ISO 8859`
- Разработайте стратегию интернационализации на самом раннем периоде развития программы

## Логические переменные

Основные принципы:

- Вместо простой проверки логического выражения, присвойте его значение переменной с понятным именем

```python
# Плохо :(
if (product.is_available && product.count >= order.count) {
  order.process()
}

# Лучше!
order_is_ready_to_process = product.is_available && product.count >= order.count
if (order_is_ready_to_process) {
  order.process()
}
```

- Раскладывайте сложные, многосоставные условия на несколько переменных с понятными именами

```python
# Плохо :(
if (order.status == ORDER_STATUSES.NEW && (product.is_available && product.count >= order.count || product.has_infinite_count)) {
  order.process()
}

# Лучше!
order_is_new = order.status == ORDER_STATUSES.NEW
products_are_enough = (product.count >= order.count) || product.has_infinite_count
if (order_is_new && products_are_enough) {
  order.process()
}
```

Давать логическим переменным понятные имена — отличный инструмент в борьбе со сложностью.

## Перечислимые типы

**Перечислимый тип данных (англ. enumeration, enumerated type)** — тип данных, чьё множество значений представляет собой ограниченный список идентификаторов.

Перечислимые типы данных:

- **Улучшают читабельность** в сравнении с числовыми константами
- **Повышают надёжность**, потому что компилятор во многих языках может провести более тщательную проверку, чем при работе с целыми значениями и константами
- **Упрощают модифицируемость** программы за счёт возможности легко добавить новое значение к переменной
- **Хорошая альтернатива логическим переменным**, когда состояние становится слишком сложным для передачи с помощью булевых значений

## Именованные константы

> Именованные константы аналогичны переменным за исключением того, что вы не можете изменить значение константы после её инициализации (с. 299)

Применение именованных констант — это отличный способ хранения некоторых характеристик программы, которые потенциально могут измениться. В некоторых языках именованные константы не поддерживаются, но можно иметировать их при помощи обычных переменных, например, модуль `settings.py` в фреймворке Django (на языке Python) обычно состоит из переменных, которые выполняют роль именованных костант — помогают параметризировать программу.

Общий принцип заключается в том, что необходимо:

- стремиться к замене всех литерал на именованные константы,
- последовательно их использовать (как минимум, заменять определённый литерал на константу во всём коде, а не в нескольких отдельных модулях).
  
Это позволит сэкономить время и силы на сопровождении программы.

> Даже если вы считаете, что литеральное значение безопасно, используйте вместо него именованную константу. Фанатично искорените литералы из вашего кода (с. 301)

## Массивы

> Массив состоит из группы элементов одинакового типа, доступ к которым осуществляется напрямую по индексу (с. 301)

- Рассмотрите возможность применения типов `Set`, `Stack`, `Queue` как альтернативу, прежде чем выбрать массив
- Убедитесь, что используемые значения индексов не выходят за пределы массива и что обращения к крайним элементам осуществляются по правильным индексам
- Убедитесь, что при обходе многомернывх массивов индексы используются в правильном порядке

## Пользовательские типы
