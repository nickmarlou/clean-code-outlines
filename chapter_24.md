# Рефакторинг

## Введение в рефакторинг

> [Мартин Фаулер](https://en.wikipedia.org/wiki/Martin_Fowler_(software_engineer)) определяет рефакторинг как **изменение внутренней структуры программы без изменения её наблюдаемого поведения, призванное облегчить понимание кода и удешевить его модификацию** (c. 553)

Зачастую код деградирует в процессе сопровождения или имеет невысокое качество изначально. На необходимость рефакторинга будет указывать множество знаков, которые иногда называют [code smell](https://en.wikipedia.org/wiki/Code_smell#:~:text=In%20computer%20programming%2C%20a%20code,%2C%20developer%2C%20and%20development%20methodology.&text=It%20is%20also%20a%20term%20used%20by%20agile%20programmers.).

### Разумные причины для выполнения рефакторинга (code smells)

- Одинаковые фрагменты кода повторяются в разных местах программы.
- Метод слишком велик (условно говоря, не помещается в экран).
- Цикл слишком велик или слишком глубоко вложен в другие циклы.
- Интерфейс класса не формирует согласованную асбтракцию.
- Метод принимает слишком много параметров.
- Отдельные части класса изменяются независимо от других частей (возможно, класс имеет несколько разных областей ответственности и тогда его нужно разделить на несколько классов).
- Несколько классов изменяются параллельно (возможно, эти классы можно объединить).
- Вам приходится параллельно изменять несколько иерархий наследования.
- Вам приходится параллельно изменить несколько условий.
- Метод использует больше элементов другого класса, чем своего собственного.
- Элементарный тип данных перегружен (для хранения денежных значений лучше создать тип `Money`, для хранения температуры – `Temperature` и так далее; это поможет избежать случаев присваивания данных неверного типа, как при использовании типа `decimal` для всех чисел с плавающей точкой).
- По цепи методов передаются бродячие данные.
- Объект-посредник ничего не делает.
- Один класс слишком много знает о другом классе (в таком случае нужно поработать над инкапсуляцией).
- Метод имеет неудачное имя (исправьте как можно быстрее!).
- Данные-члены сделаны открытыми (это редко бывает разумным решением, потому что стирает грань между интерфейсом и реализацией).
- Подкласс использует только малую долю методов своих предков.
- Сложный код объясняется при помощи комментариев (комментарий – лучше чем ничего, но еще лучше переписать код нормально).
- Код содержить глобальные переменные.
- Программа содержит код, который  «может когда-нибудь понадобится».

## Виды рефакторинга

### Рефакторинг на уровне данных

- Замена магического числа на именованную константу
- Присвоение переменной более ясного или информативного имени
- Встраивание выражения в код
- Замена выражения на вызов метода
- Введение промежуточной переменной
- Преобразование многоцелевой переменной в несколько одноцелевых переменных
- Использование локальной переменной вместо использования параметра функции в качестве локальной переменной
- Преобразование элементарного типа данных в класс
- Преобразование набора кодов в класс или `enum`
- Преобразование набора кодов в класс, имеющий производные классы
- Преобразование массива в класс, если элементами массива являются разные типы данных в единственном экземпляре
- Инкапсуляция `enum` во избежание существование нескольких экземпляров с несинхронизированными данными

### Рефакторинг на уровне отдельных операторов

- Декомпозиция логического выражения
- Вынесение сложного логического выражение в грамотно именованную функцию
- Консолидация фрагментов, повторяющихся в разных частях условного оператора
- Использование `break`/`return` вместо управляющей переменной в циклах
- Возврат из метода сразу после получения ответа вместо записи полученного ответа в переменную внутри условных операторов
- Замена условных операторов на вызов полиморфного метода
- Создание и использование «пустых» объектов вместо проверки того, равно ли значение `null`

### Рефакторинг на уровне отдельных методов

- Извлечение метода из другого метода, если он сложен
- Встраивание кода метода, если он слишком прост
- Преобразование объёмного метода в класс
- Замена сложного алгоритма на простой
- Добавление параметра
- Удаление параметра
- Отделение операций запроса данных от операций изменения данных
- Объединение похожих методов при помощи их параметризации
- Разделение метода, поведение которого зависит от полученных параметров
- Передача в метод целого объекта вместо отдельных полей
- Передача в метод отдельных полей вместо целого объекта
- Инкапсуляция нисходящего приведения типов

### Рефакторинг на уровне реализации классов

- Замена объектов-значений на объекты-ссылки
- Замена объектов-ссылок на объекты-значения
- Замена виртуальных методов на инициализацию данных
- Изменение положения методов-членов или данных-членов в иерархии наследования
- Перемещение специализированного кода в подкласс
- Объединение похожего кода и его перемещение в суперкласс

### Рефакторинг интерфейсов классов

- Перемещение метода в другой класс
- Разделение одного класса на несколько, если класс имеет более одной области ответственности
- Удаление класса, если класс почти ничего не делает
- Сокрытие делегата
- Удаление посредника
- Замена наследования на делегирование
- Замена делегирования на наследование
- Создание внешнего метода
- Инкапсуляция открытой переменной-члена
- Удаление методов установки значений неизменяемых полей
- Сокрытие методов, которые не следует вызывать извне класса
- Инкапсуляция неиспользуемых методов
- Объединение суперкласса и подкласса, имеющих очень похожую реализацию

### Рефакторинг на уровне системы

- Создание эталонного источника данных, которые вы не можете контролировать
- Изменение однонаправленной связи между классами на двунаправленную
- Изменение двунаправленной связи между классами на однонаправленную
- Предоставление фабричного метода вместо простого конструктора
- Замена кодов ошибок на исключение или наоборот

## Безопасность рефакторинга

Чтобы получить от рефакторинга только пользу и избежать вреда, следуйте этим советам:

- Сохраняйте первоначальную версию кода (скорее всего, Git это уже делает за вас, но не забудьте создать новую ветку для полной безопасности).
- Составьте список приёмов рефакторинга, которые вы хотите предпринять в ближайшее время.
- Составьте список приёмов, которые вы хотите выполнить в будущем.
- Выполняйте по одному приёму за раз и фиксируйте результат в случае успеха.
- Используйте регрессионное тестирование, чтобы убедиться, что изменения не привели к появлению ошибок.
- **Если наборы тестов не покрывают внесенные изменения, напишите дополнительные тесты или усовершенствуйте существующие.**
- Используйте предупреждения компилятора как сигналы о том, что изменения привели к ошибкам.
- Рефакторинг, как и любые другие изменения, должен быть предметом код-ревью.
- Чем масштабнее рефакторинг, тем осторожнее нужно быть.

Для безопасного рефакторинга не менее важно понимать, что рефакторинг – не панацея. Не стоит воспринимать его как повод сначала написать плохой код или как способ избежать переписывания кода.

> Иногда код невозможно улучшить небольшими изменениями – его нужно выбросить и переписать с нуля (с. 568)

## Стратегии рефакторинга

- Создавая метод, выполните рефакторинг связанных с ним методов, если это необходимо.
- Создавая новый класс, используйте эту возможность для рефакторинга связанных с ним классов.
- Проведите рефакторинг после исправления ошибки, чтобы избежать аналогичных ошибок в других фрагментах кода.
- Выполняйте рефакторинг, чтобы упростить сложные модули.
- Определите интерфейс между грязным и чистым кодом, и постепенно переносите код со стороны безобразного на сторону хорошего.

> ...каждый раз, когда вы прикасаетесь к какому-то фрагменту грязного кода, вы должны привести его в соответсвие с текущими стандартами кодирования, присвоить переменным ясные имена и т.д. – иначе говоря, переместить его в идеальный мир. Со временем это может обеспечить быстрое улучшение базы кода (с. 570)